{"version":3,"sources":["src/gravedad.js"],"names":["canvas","ctx","pelotas","gravedad","friccion","window","addEventListener","document","querySelector","getContext","init","animate","i","radius","numberBetween","x","width","y","height","color","getRandomColor","velocidad","vx","vy","pelota","Pelota","push","update","draw","beginPath","arc","Math","PI","strokeSyle","lineWidth","stroke","fillStyle","fill","closePath","clearRect","forEach","requestAnimationFrame","min","max","random","colors","index","floor","length"],"mappings":"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","file":"gravedad.83c7971a.js","sourceRoot":"..","sourcesContent":["let canvas, ctx;\nlet pelotas = [];\nconst gravedad = 1;\nconst friccion = 0.90;\n\nwindow.addEventListener('load', ()=>{\n    canvas = document.querySelector('#myCanvas');\n    ctx = canvas.getContext('2d');\n\n    init();\n    animate();\n});\n\nfunction init(){\n    pelotas = [];\n\n    for(let i=0; i < 50; i++){\n        const radius = numberBetween(10, 30);\n        let x = numberBetween(radius, canvas.width - radius);\n        let y = numberBetween(radius, canvas.height - radius);\n        const color = getRandomColor();\n        const velocidad = {\n            vx: numberBetween(-2, 2),\n            vy: numberBetween(2, 5)\n        };\n\n        const pelota = new Pelota(x, y, velocidad, radius, color);\n\n        pelotas.push(pelota);\n    }\n}\n\naddEventListener('click', ()=>{\n    init();\n});\n\n// Alternativa #1: Crear una clase, su constructor y definir los métodos\n// Alternativa #2: Hacer un prototipo por cada función de \"Circle\"\nfunction Pelota(x, y, velocidad, radius, color){\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.color = color;\n    this.velocidad = velocidad;\n\n    this.update = function(){\n        this.draw();\n\n        // - Si la pelota quiere salirse del canvas => invertimos el sentido de dirección\n        // - Al cambiar el sentido\n        // 1. generamos el efecto de rebote contra una superficie\n        // 2. contenemos la pelota dentro del canvas\n        // - Debemos sumar la velocidad vy, para evitar que parte de la pelota quede por fuera del canvas\n        if(this.y + this.radius + this.velocidad.vy >= canvas.height){\n            // - multiplicamos por -1 para cambiar el sentido\n            // - multiplicamos por un valor de fricción, esa fricción reduce la velocidad hasta que quede\n            // en reposo (detenida)\n            this.velocidad.vy = (-1) * this.velocidad.vy * friccion;\n        }\n        else{\n            // si la pelota cae dentro del canvas => incrementamos en 1 su velocidad en el Eje-Y\n            this.velocidad.vy += gravedad;\n        }\n\n        // - Generamos un efecto de rebote con los bordes del Canvas, limitamos su movimiento dentro del canvas\n        // - Invertimos el sentido de dirección si y sólo si..\n        // 1. Si la posición actual + el radio de la pelota es mayor al ancho del Canvas (trate de irse hacia la der.)\n        // 2. Si la posición actual es menor o igual a su radio, trata de irse hacia la izq. del Canvas\n        if(this.x+this.radius > canvas.width || this.x <= this.radius){\n            this.velocidad.vx = (-1) * this.velocidad.vx;\n        }\n\n\n        // actualizamos su posición en eje-y, emulando un movimiento vertical (hacia abajo ó arriba)\n        this.y += this.velocidad.vy;\n        // actualizaos su posición en eje-x, emulando que se desplaza hacia los costados\n        this.x += this.velocidad.vx;\n    };\n\n    this.draw = function(){\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI); // (posX, posY, radio, anguloInicial, anguloFinal)\n\n        ctx.strokeSyle = this.color;\n        ctx.lineWidth = 4; // cambiamos el grosor del borde\n        ctx.stroke(); // dibuja el borde de la figura\n\n        ctx.fillStyle = this.color;\n        ctx.fill(); // rellena la figura\n\n        ctx.closePath();\n    };\n}\n\n// animation loop, recursive function\n// Alternativa? Usar setInterval (aunque... para animaciones se\n// sugiere requestAnimationFrame)\nfunction animate(){\n    // limpia las frames anteriores\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    pelotas.forEach( pelota => {\n        pelota.update();\n    });\n\n    // esto produce la recursividad\n    requestAnimationFrame(animate);\n}\n\n// ---------------------------------------------------------------------------\\\\\n// funciones auxiliares\nfunction numberBetween(min, max){\n    return Math.random() * (max - min) + min;\n}\n\nfunction getRandomColor(){\n    const colors = ['red', 'blue', 'orange', 'green'];\n    const index = Math.floor(numberBetween(0, colors.length));\n    return colors[index];\n}\n"]}